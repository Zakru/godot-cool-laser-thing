shader_type particles;

// We apply velocity ourselves
render_mode disable_velocity;

// The scale multiplier of each particle
uniform float scale = 1;

// The velocity at which particles will move forwards
uniform float forward_velocity = 0;

// The randomness ratio of the forward velocity
// (the forward velocity varies randomly between forward_velocity +- random)
uniform float velocity_random : hint_range(0, 1) = 0;

// The visual "rotations" the particles perform every second
uniform float rotations_per_second = 1;

// The randomness ratio of the rotations per second
uniform float rotation_random : hint_range(0, 1) = 0;

// The radius of the circular arc the particles apparently follow
uniform float rotation_radius = 0;

// The randomness ratio of the rotation radius
uniform float radius_random : hint_range(0, 1) = 0;

// The length in which particles are emitted. Particles moving past this length
// also wrap around to the beginning.
uniform float emission_length = 128;

// The "intensity" value. Affects velocity, RPS and radius.
uniform float intensity = 1;

// A color multiplier
uniform vec4 color_value : hint_color;


// These three functions are generated by the conversion from ShaderMaterial.
// They do some magic for pseudo-random number generation.
float rand_from_seed(inout uint seed) {
	int k;
	int s = int(seed);
	if (s == 0)
	s = 305420679;
	k = s / 127773;
	s = 16807 * (s - k * 127773) - 2836 * k;
	if (s < 0)
		s += 2147483647;
	seed = uint(s);
	return float(seed % uint(65536)) / 65535.0;
}

float rand_from_seed_m1_p1(inout uint seed) {
	return rand_from_seed(seed) * 2.0 - 1.0;
}

uint hash(uint x) {
	x = ((x >> uint(16)) ^ x) * uint(73244475);
	x = ((x >> uint(16)) ^ x) * uint(73244475);
	x = (x >> uint(16)) ^ x;
	return x;
}

void vertex() {
	uint base_number = NUMBER;
	uint alt_seed = hash(base_number + uint(1) + RANDOM_SEED);
	const float pi = 3.14159;

	// If lifetime was exceeded last frame...
	bool restart = false;
	if (CUSTOM.y > 1.0) {
		restart = true;
	}

	// ...or Godot wants us to restart this particle, then restart it.
	if (RESTART || restart) {
		// CUSTOM is a vec4 containing any data we want. In this case, we have
		//   x - The "angle" in radians which the particle has rotated
		//   y - The percentage of the particle's lifetime that has passed
		//   z - A random modifier for the rotation radius
		//   w - A random modifier for the RPS

		// Set x to a random rotation
		CUSTOM.x = rand_from_seed(alt_seed) * 2.0 * pi;

		// Set the passed lifetime to 0
		CUSTOM.y = 0.0;

		// Set these two to random values between -1 and 1
		CUSTOM.z = rand_from_seed_m1_p1(alt_seed);
		CUSTOM.w = rand_from_seed_m1_p1(alt_seed);

		// Set the particle's position to a random point on the line from the
		// Particles2D's origin to the point at y coordinate emission_length
		TRANSFORM[3].xyz = vec3(0, rand_from_seed(alt_seed), 0) * emission_length;

		// Set the velocity to forward_velocity with a random modifier
		VELOCITY = vec3(0.0, forward_velocity + rand_from_seed_m1_p1(alt_seed) * velocity_random * forward_velocity, 0.0);
	} else {
		// Increase passed lifetime
		CUSTOM.y += DELTA / LIFETIME;

		// Increase angle according to rotations_per_second, the random modifier
		// and intensity.
		CUSTOM.x += 2.0 * pi * (rotations_per_second + CUSTOM.w * rotations_per_second * rotation_random) * DELTA * intensity * intensity;

		// Apply the velocity multiplied by intensity
		TRANSFORM[3].xyz += VELOCITY * DELTA * intensity;

		// Make sure the particles wrap around
		TRANSFORM[3].y = mod(TRANSFORM[3].y, emission_length);
	}

	// Set the final color multiplier
	COLOR = color_value;

	// Set the basis vectors of the transform
	TRANSFORM[0] = vec4(1.0, 0.0, 0.0, 0.0);
	TRANSFORM[1] = vec4(0.0, 1.0, 0.0, 0.0);
	TRANSFORM[2] = vec4(0.0, 0.0, 1.0, 0.0);

	// Scale the particle with a quadratic function -(2*life_passed - 1) ^ 2 + 1
	float scale_x = 2.0 * CUSTOM.y - 1.0;
	float base_scale = scale * (-scale_x * scale_x + 1.0);
	if (base_scale < 0.000001) {
		base_scale = 0.000001;
	}
	TRANSFORM[0].xyz *= base_scale;
	TRANSFORM[1].xyz *= base_scale;
	TRANSFORM[2].xyz *= base_scale;

	// Finally, set the x coordinate according to the current "angle" (CUSTOM.x)
	// and the radius.
	TRANSFORM[3].x = sin(CUSTOM.x) * (rotation_radius + CUSTOM.z * radius_random
	 * rotation_radius) / intensity;

	// If lifetime has been exceeded, tell Godot this particle is inactive.
	if (CUSTOM.y > 1.0) {
		ACTIVE = false;
	}
}

